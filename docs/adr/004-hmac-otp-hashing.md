# ADR-004: HMAC-Based OTP Hashing

**Status:** Accepted
**Date:** 2026-02

## Context

CueBX uses one-time passwords (OTPs) for email verification and password reset. OTPs are 6-digit numeric codes stored in the `otp_tokens` table with a 10-minute expiry and a 5-attempt limit. We needed to decide how to store OTP codes securely.

## Decision

Use **HMAC-SHA256** (with a server-side secret) for OTP hashing, instead of bcrypt.

```python
# Hashing
hash = hmac.new(secret.encode(), otp.encode(), hashlib.sha256).hexdigest()

# Verification (constant-time)
hmac.compare_digest(hash, stored_hash)
```

Key properties:

- **Deterministic** — same input always produces the same hash (given the same secret)
- **Fast** — microseconds vs. bcrypt's ~100ms
- **Enables DB lookup** — `SELECT * FROM otp_tokens WHERE code_hash = ?`

Passwords continue to use **bcrypt** (non-deterministic, salted).

## Alternatives Considered

| Alternative | Why not |
| --- | --- |
| **Bcrypt (same as passwords)** | Non-deterministic — can't do `WHERE code_hash = ?`. Would need to load all active OTPs for a user and compare each one sequentially. Scales poorly. |
| **Plaintext storage** | Database breach exposes all active OTPs. Violates security-at-rest. |
| **SHA-256 (no HMAC)** | OTPs are only 6 digits — a plain SHA-256 table of all 1M possibilities is trivially precomputable. HMAC with a server secret prevents this. |
| **TOTP (RFC 6238)** | Requires shared secret provisioned to user's device (authenticator app). Our flow is email-based — the OTP is sent to the user, not generated by them. |

## Consequences

**Positive:**

- OTPs are looked up by hash in a single indexed query — O(1)
- A database breach does not expose active OTPs (attacker would need the HMAC secret)
- Constant-time comparison via `hmac.compare_digest()` prevents timing attacks
- Fast hashing means no performance impact on high-OTP-volume flows

**Negative:**

- Security depends entirely on the HMAC secret (`OTP_HMAC_SECRET`). Compromise of this secret + database access = all active OTPs exposed
- Mitigated by: short expiry (10 min), max attempts (5), rate limiting, and production secret validation at startup
